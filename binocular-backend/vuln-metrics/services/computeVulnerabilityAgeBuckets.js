'use strict';

import VersionChangeEvent from '../../models/VersionChangeEvent.js';
import Vulnerability from '../../models/Vulnerability.js';
import VersionChangeEventVulnerabilityConnection from '../../models/VersionChangeEventVulnerabilityConnection.js';
import VulnerabilityAgeBucket from '../../models/VulnerabilityAgeBucket.js';
import semver from 'semver';
import debug from 'debug';

const log = debug('vuln-metrics:age-buckets');
const DAY_MS = 1000 * 60 * 60 * 24;

function getBucket(ageDays) {
  if (ageDays <= 30) return '0-30';
  if (ageDays <= 90) return '31-90';
  if (ageDays <= 180) return '91-180';
  return '181+';
}

function addWeeks(date, w) {
  const copy = new Date(date);
  copy.setDate(copy.getDate() + w * 7);
  return copy;
}

export async function computeVulnerabilityAgeBucketsInterpolated(branch = 'main') {
  log(`Computing vulnerability age buckets for branch ${branch}`);

  const events = (await VersionChangeEvent.findAll())
    .filter((e) => e.branchName === branch)
    .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

  if (!events.length) return [];

  const results = [];
  const openVulns = new Map();

  for (let i = 0; i < events.length; i++) {
    const event = events[i];
    const nextEvent = events[i + 1];
    const currentDate = new Date(event.timestamp * 1000);

    const conns = await VersionChangeEventVulnerabilityConnection.findByEvent(event._key);
    for (const conn of conns) {
      const vulId = conn._to.split('/')[1];
      const vuln = await Vulnerability.findById(vulId);
      if (!vuln || !vuln.vulnId || !vuln.publishedAt) continue;

      if (!openVulns.has(vuln.vulnId)) {
        openVulns.set(vuln.vulnId, {
          introducedAt: currentDate,
          disclosureAt: new Date(vuln.publishedAt),
          fixedAt: null,
        });
      }

      const patchedRanges = vuln.patchedVersions || [];
      const newVersion = event.newVersion;

      if (patchedRanges.length && newVersion && semver.valid(newVersion)) {
        for (const range of patchedRanges) {
          try {
            if (semver.satisfies(newVersion, range)) {
              openVulns.get(vuln.vulnId).fixedAt = currentDate;
              break;
            }
          } catch (err) {
            /* empty */
          }
        }
      }
    }

    const nextDate = nextEvent ? new Date(nextEvent.timestamp) : currentDate;
    const daysBetween = (nextDate - currentDate) / DAY_MS;
    const steps = Math.max(1, Math.floor(daysBetween / 7));

    for (let step = 0; step <= steps; step++) {
      const snapshotDate = addWeeks(currentDate, step);
      const buckets = { '0-30': 0, '31-90': 0, '91-180': 0, '181+': 0 };

      for (const info of openVulns.values()) {
        const intro = info.introducedAt;
        const disclosure = info.disclosureAt;
        const fixed = info.fixedAt;
        if (intro > snapshotDate) continue;
        if (fixed && fixed <= snapshotDate) continue;

        const start = intro > disclosure ? intro : disclosure;
        const ageDays = (snapshotDate - start) / DAY_MS;
        if (ageDays < 0) continue;

        const bucket = getBucket(ageDays);
        buckets[bucket]++;
      }

      results.push({ date: snapshotDate, ...buckets });
    }
  }

  log(`Computed ${results.length} snapshots`);

  await VulnerabilityAgeBucket.collection.removeByExample({ branch });

  for (const item of results) {
    VulnerabilityAgeBucket.persist({
      branch,
      date: item.date.toISOString(),
      buckets: {
        '0-30': item['0-30'],
        '31-90': item['31-90'],
        '91-180': item['91-180'],
        '181+': item['181+'],
      },
      createdAt: new Date().toISOString(),
    });
  }

  log(`Stored vulnerability age buckets for branch "${branch}"`);
  return results;
}
