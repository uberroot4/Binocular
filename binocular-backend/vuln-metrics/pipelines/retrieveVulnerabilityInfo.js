import fetch from 'node-fetch';
import fs from 'fs/promises';
import path from 'path';

const OSV_BASE = 'https://api.osv.dev/v1';
const OSV_LOCAL_DIR = path.resolve(process.cwd(), 'osv-data/osv-npm');
const CONCURRENCY = 5;
const BATCH_SIZE = 100;
const BATCH_DELAY_MS = 500;

/**
 * Main entry — Retrieve and enrich vulnerability info for npm libraries.
 * Uses OSV batch query for IDs and local dataset for full details.
 */
export async function retrieveVulnerabilityInfo(libraries) {
  const libs = Array.isArray(libraries) ? libraries : [libraries];
  if (!libs.length) return [];

  console.log(`[${new Date().toISOString()}] Querying OSV for ${libs.length} libraries...`);

  const batchResponse = await queryBatchOSV(libs, BATCH_SIZE);
  const pkgToVulnIds = extractPackageToVulns(batchResponse);

  const allVulnIds = [...new Set(Object.values(pkgToVulnIds).flat())];
  console.log(`[${new Date().toISOString()}] Retrieved ${allVulnIds.length} unique vulnerability IDs.`);

  const vulnDetails = await loadVulnerabilityDetails(allVulnIds, CONCURRENCY);

  const results = Object.entries(pkgToVulnIds).map(([pkg, vulnIds]) => ({
    library: pkg,
    vulnerabilities: vulnIds
      .map((id) => vulnDetails.find((v) => v.vulnId === id))
      .filter(Boolean),
  }));

  console.log(`[${new Date().toISOString()}] Enriched data for ${results.length} libraries.`);
  return results;
}

/**
 * Query OSV batch endpoint for multiple npm packages in manageable chunks.
 */
async function queryBatchOSV(libraries, chunkSize = 100) {
  const allResults = [];
  const allQueries = [];

  for (let i = 0; i < libraries.length; i += chunkSize) {
    const chunk = libraries.slice(i, i + chunkSize);
    const queries = chunk.map((name) => ({
      package: { name: name.trim(), ecosystem: 'npm' },
    }));

    console.log(`[${new Date().toISOString()}] Querying OSV batch chunk (${i + 1}-${i + chunk.length})...`);

    try {
      const res = await fetch(`${OSV_BASE}/querybatch`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ queries }),
      });

      if (!res.ok) {
        console.warn(`[OSV] Batch query failed for chunk starting at index ${i}: ${res.status}`);
        continue;
      }

      const json = await res.json();
      allResults.push(...json.results);
      allQueries.push(...queries);
    } catch (err) {
      console.error(`[OSV] Error fetching batch starting at ${i}:`, err.message);
    }

    await new Promise((r) => setTimeout(r, BATCH_DELAY_MS));
  }

  return { results: allResults, queries: allQueries };
}

/**
 * Build package → vulnerability ID mapping.
 */
function extractPackageToVulns(batchData) {
  const mapping = {};
  for (let i = 0; i < (batchData.results || []).length; i++) {
    const result = batchData.results[i];
    const pkgName = batchData.queries?.[i]?.package?.name || `pkg_${i}`;
    const vulnIds = (result.vulns || []).map((v) => v.id);
    mapping[pkgName] = vulnIds;
  }
  return mapping;
}

/**
 * Load vulnerability details from local OSV dataset using limited concurrency.
 */
async function loadVulnerabilityDetails(vulnIds, concurrency = 5) {
  const results = [];
  const queue = [...vulnIds];

  async function worker() {
    while (queue.length) {
      const id = queue.shift();
      const file = path.join(OSV_LOCAL_DIR, `${id}.json`);
      try {
        const raw = await fs.readFile(file, 'utf-8');
        const json = JSON.parse(raw);
        results.push(normalizeOSVVulnerability(json));
      } catch {
        console.warn(`[Local] Missing file for ${id}`);
      }
    }
  }

  const workers = Array.from({ length: concurrency }, () => worker());
  await Promise.all(workers);
  return results;
}

/**
 * Normalize OSV vulnerability response.
 */
function normalizeOSVVulnerability(vuln) {
  const affectedVersions = extractVersions(vuln.affected || []);
  const cwe = vuln.database_specific?.cwe_ids || [];
  const severity = vuln.database_specific?.severity || 'UNKNOWN';
  const cve = vuln.aliases?.find((a) => a.startsWith('CVE-')) || null;

  return {
    source: 'osv-local',
    vulnId: vuln.id,
    cve,
    cwe,
    severity,
    cvssScore: vuln.cvss?.score || null,
    advisoryUrl: vuln.references?.[0]?.url || '',
    title: vuln.summary || '',
    description: vuln.details || '',
    affectedVersions,
    publishedAt: vuln.published || null,
    lastModifiedAt: vuln.modified || null,
  };
}

/**
 * Extract version numbers or ranges from OSV "affected" section.
 */
function extractVersions(affected) {
  const versions = new Set();

  for (const a of affected) {
    if (a.versions?.length) {
      a.versions.forEach((v) => versions.add(v));
    }
    for (const range of a.ranges || []) {
      if (range.type === 'SEMVER' && Array.isArray(range.events)) {
        for (const e of range.events) {
          if (e.introduced && e.introduced !== '0') versions.add(`>=${e.introduced}`);
          if (e.fixed) versions.add(`<${e.fixed}`);
        }
      }
    }
  }

  return versions.size ? [...versions] : null;
}
